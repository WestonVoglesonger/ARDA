``` path=algorithms/fft256/algo.py
"""
256-Point FFT Algorithm - Cooley-Tukey Implementation
Complex fixed-point arithmetic for FPGA acceleration
"""

import numpy as np
from typing import List, Tuple, Optional
import math
import cmath

class ComplexFP:
    """Fixed-point complex number representation."""
    def __init__(self, real: float, imag: float, total_bits: int = 16, frac_bits: int = 12):
        self.total_bits = total_bits
        self.frac_bits = frac_bits
        self.int_bits = total_bits - frac_bits - 1  # -1 for sign bit

        # Convert to fixed-point
        scale = 2 ** frac_bits
        self.real_fp = int(real * scale)
        self.imag_fp = int(imag * scale)

        # Clamp to range
        max_val = (1 << (total_bits - 1)) - 1
        min_val = -(1 << (total_bits - 1))
        self.real_fp = max(min_val, min(max_val, self.real_fp))
        self.imag_fp = max(min_val, min(max_val, self.imag_fp))

    def to_float(self) -> complex:
        scale = 2 ** self.frac_bits
        return complex(self.real_fp / scale, self.imag_fp / scale)

    def __add__(self, other):
        return ComplexFP(
            (self.real_fp + other.real_fp) / (2 ** self.frac_bits),
            (self.imag_fp + other.imag_fp) / (2 ** self.frac_bits),
            self.total_bits, self.frac_bits
        )

    def __sub__(self, other):
        return ComplexFP(
            (self.real_fp - other.real_fp) / (2 ** self.frac_bits),
            (self.imag_fp - other.imag_fp) / (2 ** self.frac_bits),
            self.total_bits, self.frac_bits
        )

    def __mul__(self, other):
        # Complex multiplication: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
        a, b = self.real_fp, self.imag_fp
        c, d = other.real_fp, other.imag_fp

        real_result = (a * c - b * d) >> self.frac_bits
        imag_result = (a * d + b * c) >> self.frac_bits

        return ComplexFP(
            real_result / (2 ** self.frac_bits),
            imag_result / (2 ** self.frac_bits),
            self.total_bits, self.frac_bits
        )

def generate_twiddle_factors(N: int, fp_config: dict) -> List[ComplexFP]:
    """Generate twiddle factors for FFT."""
    twiddles = []
    for k in range(N // 2):
        angle = -2 * math.pi * k / N
        twiddle = cmath.exp(1j * angle)
        twiddles.append(ComplexFP(
            twiddle.real, twiddle.imag,
            fp_config['total_bits'], fp_config['frac_bits']
        ))
    return twiddles

def bit_reverse_permutation(n: int, size: int) -> int:
    """Bit reversal for FFT input ordering."""
    result = 0
    for i in range(size):
        result = (result << 1) | (n & 1)
        n >>= 1
    return result

def fft_256(input_data: List[complex], fp_config: dict) -> List[complex]:
    """
    256-point FFT implementation using Cooley-Tukey algorithm.

    Args:
        input_data: 256 complex input samples
        fp_config: Fixed-point configuration

    Returns:
        256 complex frequency domain samples
    """
    N = 256
    stages = 8  # log2(256) = 8

    # Convert input to fixed-point complex numbers
    x = [ComplexFP(sample.real, sample.imag,
                   fp_config['total_bits'], fp_config['frac_bits'])
         for sample in input_data]

    # Bit reversal permutation
    for i in range(N):
        j = bit_reverse_permutation(i, stages)
        if j > i:
            x[i], x[j] = x[j], x[i]

    # FFT computation stages
    for stage in range(stages):
        span = 1 << stage  # 1, 2, 4, 8, 16, 32, 64, 128
        for start in range(0, N, 2 * span):
            # Twiddle factor for this stage
            k = start // (2 * span)
            twiddle = generate_twiddle_factors(2 * span, fp_config)[k]

            for offset in range(span):
                i = start + offset
                j = start + offset + span

                # Butterfly operation
                temp = x[j] * twiddle
                x[j] = x[i] - temp
                x[i] = x[i] + temp

    # Convert back to floating point
    return [sample.to_float() for sample in x]

def fft_step_function(input_samples: List[float], config: dict) -> List[float]:
    """
    FFT processing step function - processes 256 real samples into frequency domain.

    Args:
        input_samples: 256 real input samples
        config: Configuration dictionary with fp_config

    Returns:
        512 values: 256 real + 256 imaginary frequency components
    """
    if len(input_samples) != 256:
        raise ValueError("FFT requires exactly 256 input samples")

    # Convert real input to complex (imaginary part = 0)
    complex_input = [complex(sample, 0.0) for sample in input_samples]

    # Perform FFT
    fp_config = config.get('fp_config', {
        'total_bits': 16,
        'frac_bits': 12
    })

    result = fft_256(complex_input, fp_config)

    # Return as interleaved real/imaginary
    output = []
    for sample in result:
        output.extend([sample.real, sample.imag])

    return output

# Test function for validation
def test_fft():
    """Test FFT with known input."""
    # Generate test signal: sum of two sinusoids
    N = 256
    t = np.linspace(0, 1, N, endpoint=False)
    f1, f2 = 10, 40  # Hz
    signal = np.sin(2 * np.pi * f1 * t) + 0.5 * np.sin(2 * np.pi * f2 * t)

    fp_config = {'total_bits': 16, 'frac_bits': 12}

    # Perform FFT
    result = fft_256([complex(s, 0) for s in signal], fp_config)
    result_float = [r.to_float() for r in result]

    # Check that we get peaks at f1 and f2
    magnitudes = [abs(r) for r in result_float]

    # Find peaks (should be at indices f1 and f2)
    peak1_idx = np.argmax(magnitudes[:N//2])
    peak2_idx = np.argmax(magnitudes[f2-5:f2+5]) + f2 - 5

    print(f"Peak 1 at frequency index: {peak1_idx} (expected: {f1})")
    print(f"Peak 2 at frequency index: {peak2_idx} (expected: {f2})")

    return result_float

if __name__ == "__main__":
    test_fft()

```

``` path=algorithms/fft256/meta.yaml
algorithm:
  name: "FFT256"
  description: "256-point Fast Fourier Transform using Cooley-Tukey algorithm with fixed-point arithmetic"
  version: "1.0"
  author: "ARDA Pipeline"
  license: "MIT"

interface:
  input:
    type: "real_array"
    size: 256
    data_type: "float32"
    description: "256 real-valued time-domain samples"

  output:
    type: "complex_array"
    size: 256
    data_type: "complex64"
    description: "256 complex frequency-domain coefficients (real/imaginary interleaved)"

  step_function: "fft_step_function"

performance:
  target_frequency_mhz: 150.0
  throughput_samples_per_second: 38400000  # 256 samples * 150MHz
  latency_cycles_max: 4096  # Allow for pipelined implementation
  power_budget_mw: 500

resource_budget:
  lut: 15000
  ff: 20000
  dsp: 64
  bram: 16

fp_config:
  total_bits: 16
  frac_bits: 12
  input_format:
    width: 16
    fractional_bits: 12
  coeff_format:
    width: 16
    fractional_bits: 13
  output_format:
    width: 18
    fractional_bits: 14

implementation:
  architecture: "streaming_pipeline"
  stages: 8  # log2(256)
  memory_type: "distributed_ram"  # For twiddle factors
  optimization_goals:
    - "timing_closure"
    - "resource_efficiency"
    - "numerical_accuracy"

verification:
  test_vectors_count: 100
  accuracy_threshold_db: 60  # SNR requirement
  corner_cases:
    - "dc_signal"
    - "nyquist_frequency"
    - "impulse_response"
    - "noise_floor"
  golden_reference: "numpy.fft.fft"

axi_interface:
  data_width: 32  # 16-bit real + 16-bit imaginary
  addr_width: 8   # log2(256)
  max_burst_length: 256

```

``` path=algorithms/fft256/vectors.py
"""
Test vectors for 256-point FFT validation
"""

import numpy as np
import json
from typing import Dict, List, Any

def generate_test_vectors() -> Dict[str, Any]:
    """Generate comprehensive test vectors for FFT validation."""

    N = 256
    test_vectors = {}

    # Test Case 1: DC signal (should have peak at frequency 0)
    dc_signal = np.ones(N)
    test_vectors['dc_signal'] = {
        'input': dc_signal.tolist(),
        'description': 'DC signal - all ones',
        'expected_peaks': [{'frequency': 0, 'magnitude': N}]
    }

    # Test Case 2: Single tone at frequency 10
    t = np.linspace(0, 1, N, endpoint=False)
    tone_10hz = np.sin(2 * np.pi * 10 * t)
    test_vectors['tone_10hz'] = {
        'input': tone_10hz.tolist(),
        'description': 'Single tone at frequency index 10',
        'expected_peaks': [{'frequency': 10, 'magnitude': N/2}]
    }

    # Test Case 3: Two tones
    tone_mixed = np.sin(2 * np.pi * 15 * t) + 0.7 * np.sin(2 * np.pi * 45 * t)
    test_vectors['two_tones'] = {
        'input': tone_mixed.tolist(),
        'description': 'Two tones at frequencies 15 and 45',
        'expected_peaks': [
            {'frequency': 15, 'magnitude': N/2},
            {'frequency': 45, 'magnitude': 0.7 * N/2}
        ]
    }

    # Test Case 4: Impulse response
    impulse = np.zeros(N)
    impulse[0] = 1.0
    test_vectors['impulse'] = {
        'input': impulse.tolist(),
        'description': 'Unit impulse at index 0',
        'expected_flat_spectrum': True
    }

    # Test Case 5: Nyquist frequency (fs/2)
    nyquist = np.sin(2 * np.pi * 128 * t)  # Frequency index 128
    test_vectors['nyquist'] = {
        'input': nyquist.tolist(),
        'description': 'Nyquist frequency (fs/2)',
        'expected_peaks': [{'frequency': 128, 'magnitude': N/2}]
    }

    # Test Case 6: White noise (should have flat spectrum)
    np.random.seed(42)  # For reproducible results
    noise = np.random.normal(0, 0.5, N)
    test_vectors['white_noise'] = {
        'input': noise.tolist(),
        'description': 'White Gaussian noise',
        'expected_flat_spectrum': True
    }

    # Test Case 7: Rectangular window
    rect_window = np.ones(N)
    rect_window[N//4:3*N//4] = 0.5
    test_vectors['rect_window'] = {
        'input': rect_window.tolist(),
        'description': 'Rectangular window function',
        'expected_sinc_response': True
    }

    # Test Case 8: Chirp signal (linear frequency sweep)
    chirp = np.sin(2 * np.pi * (10 + 0.1 * np.arange(N)) * t)
    test_vectors['chirp'] = {
        'input': chirp.tolist(),
        'description': 'Linear frequency chirp from 10 to 26 Hz',
        'expected_chirp_response': True
    }

    return test_vectors

def generate_golden_reference(input_signal: List[float]) -> List[float]:
    """Generate golden reference FFT using numpy."""
    complex_input = [complex(x, 0) for x in input_signal]
    fft_result = np.fft.fft(complex_input)

    # Return as interleaved real/imaginary
    output = []
    for sample in fft_result:
        output.extend([sample.real, sample.imag])

    return output

def validate_fft_output(output: List[float], reference: List[float],
                       tolerance: float = 1e-3) -> Dict[str, Any]:
    """Validate FFT output against golden reference."""

    if len(output) != len(reference):
        return {
            'valid': False,
            'error': f'Length mismatch: {len(output)} vs {len(reference)}'
        }

    # Calculate SNR
    output_complex = []
    ref_complex = []
    for i in range(0, len(output), 2):
        output_complex.append(complex(output[i], output[i+1]))
        ref_complex.append(complex(reference[i], reference[i+1]))

    # Compute error
    error = np.array(output_complex) - np.array(ref_complex)
    signal_power = np.mean(np.abs(np.array(ref_complex))**2)
    noise_power = np.mean(np.abs(error)**2)

    if signal_power > 1e-12 and noise_power > 1e-12:
        snr_db = 10 * np.log10(signal_power / noise_power)
    else:
        snr_db = 100.0  # Perfect SNR if no noise or signal

    max_error = np.max(np.abs(error))
    rms_error = np.sqrt(np.mean(np.abs(error)**2))

    return {
        'valid': bool(snr_db > 40),  # Require 40dB SNR
        'snr_db': float(snr_db),
        'max_error': float(max_error),
        'rms_error': float(rms_error),
        'tolerance_met': bool(max_error < tolerance)
    }

if __name__ == "__main__":
    # Generate and save test vectors
    test_vectors = generate_test_vectors()

    # Generate golden references for each test case
    for test_name, test_data in test_vectors.items():
        reference = generate_golden_reference(test_data['input'])
        test_vectors[test_name]['golden_reference'] = reference

        # Validate the golden reference against itself (should be perfect)
        validation = validate_fft_output(reference, reference)
        test_vectors[test_name]['self_validation'] = validation

    # Save to JSON
    with open('fft256_test_vectors.json', 'w') as f:
        json.dump(test_vectors, f, indent=2)

    print(f"Generated {len(test_vectors)} test vectors for FFT256")
    print("Test vectors saved to fft256_test_vectors.json")

```
