"""
RTL Simulator Integration for ALG2SV
Provides real integration with ModelSim, Questa, VCS, and other simulators
"""

import os
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
import re
import time
import json
import numpy as np

from agents import function_tool  # Real OpenAI Agents SDK


class SimulatorIntegration:
    """Main interface for RTL simulator integration."""

    def __init__(self):
        self.modelsim_available = self._check_modelsim()
        self.questa_available = self._check_questa()
        self.vcs_available = self._check_vcs()
        self.iverilog_available = self._check_iverilog()

    def _check_modelsim(self) -> bool:
        """Check if ModelSim is available."""
        try:
            result = subprocess.run(['vsim', '-version'],
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def _check_questa(self) -> bool:
        """Check if Questa is available."""
        try:
            result = subprocess.run(['vsim', '-version'],
                                  capture_output=True, text=True, timeout=10)
            # Questa uses the same vsim command but different version string
            return result.returncode == 0 and 'Questa' in result.stdout
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def _check_vcs(self) -> bool:
        """Check if VCS is available."""
        try:
            result = subprocess.run(['vcs', '-ID'],
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def _check_iverilog(self) -> bool:
        """Check if Icarus Verilog is available."""
        try:
            result = subprocess.run(['iverilog', '-V'],
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def get_available_simulators(self) -> List[str]:
        """Get list of available simulators."""
        simulators = []
        if self.modelsim_available:
            simulators.append('modelsim')
        if self.questa_available:
            simulators.append('questa')
        if self.vcs_available:
            simulators.append('vcs')
        if self.iverilog_available:
            simulators.append('iverilog')
        return simulators

    def generate_testbench(self,
                          top_module: str,
                          rtl_files: List[str],
                          test_vectors: Dict[str, Any],
                          output_dir: str) -> str:
        """
        Generate SystemVerilog testbench for the design.

        Args:
            top_module: Top-level module name
            rtl_files: List of RTL file paths
            test_vectors: Test vector data (input/output arrays)
            output_dir: Output directory for testbench

        Returns:
            Path to generated testbench file
        """
        testbench_path = os.path.join(output_dir, f"{top_module}_tb.sv")
        
        # Extract test data
        input_data = test_vectors.get('input', [])
        expected_data = test_vectors.get('expected', [])
        num_samples = len(input_data)
        
        # Generate testbench content
        testbench_content = f"""// Auto-generated testbench for {top_module}
// Generated by ALG2SV Simulator Integration

`timescale 1ns/1ps

module {top_module}_tb();

    // Clock and reset signals
    reg clk;
    reg rst_n;
    
    // DUT interface signals
    reg [11:0] data_in;      // Input data
    reg valid_in;            // Input valid
    wire [15:0] data_out;    // Output data
    wire valid_out;          // Output valid
    wire ready_in;           // Input ready
    
    // Test vectors
    reg [11:0] test_inputs [{num_samples-1}:0];
    reg [15:0] expected_outputs [{num_samples-1}:0];
    
    // Test control
    integer test_idx;
    integer error_count;
    integer total_tests;
    real max_error;
    real rms_error;
    real abs_error;
    
    // Instantiate DUT
    {top_module} dut (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(data_in),
        .valid_in(valid_in),
        .data_out(data_out),
        .valid_out(valid_out),
        .ready_in(ready_in)
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 100MHz clock
    end
    
    // Test vector initialization
    initial begin
        // Initialize test vectors
"""

        # Add test vector initialization
        for i, (in_val, out_val) in enumerate(zip(input_data, expected_data)):
            testbench_content += f"        test_inputs[{i}] = 12'd{int(in_val * 2048)};\n"
            testbench_content += f"        expected_outputs[{i}] = 16'd{int(out_val * 16384)};\n"

        testbench_content += f"""
        // Initialize signals
        rst_n = 0;
        data_in = 0;
        valid_in = 0;
        test_idx = 0;
        error_count = 0;
        total_tests = {num_samples};
        max_error = 0.0;
        rms_error = 0.0;
        
        // Reset sequence
        #100;
        rst_n = 1;
        #50;
        
        $display("Starting {top_module} verification test...");
        $display("Total test vectors: %0d", total_tests);
        
        // Run tests
        for (test_idx = 0; test_idx < total_tests; test_idx = test_idx + 1) begin
            @(posedge clk);
            
            // Apply input
            data_in = test_inputs[test_idx];
            valid_in = 1;
            
            // Wait for output
            wait(valid_out);
            @(posedge clk);
            
            // Check output
            abs_error = $itor(data_out) - $itor(expected_outputs[test_idx]);
            if (abs_error < 0) abs_error = -abs_error;
            
            if (abs_error > 1.0) begin  // Allow 1 LSB tolerance
                error_count = error_count + 1;
                $display("ERROR at test %0d: expected=%0d, got=%0d, error=%0.2f", 
                         test_idx, expected_outputs[test_idx], data_out, abs_error);
            end
            
            if (abs_error > max_error) max_error = abs_error;
            rms_error = rms_error + abs_error * abs_error;
            
            valid_in = 0;
            @(posedge clk);
        end
        
        // Calculate final statistics
        rms_error = rms_error / total_tests;
        rms_error = $sqrt(rms_error);
        
        $display("\\n=== Test Results ===");
        $display("Total tests: %0d", total_tests);
        $display("Passed: %0d", total_tests - error_count);
        $display("Failed: %0d", error_count);
        $display("Max error: %0.2f", max_error);
        $display("RMS error: %0.2f", rms_error);
        
        if (error_count == 0) begin
            $display("*** ALL TESTS PASSED ***");
        end else begin
            $display("*** %0d TESTS FAILED ***", error_count);
        end
        
        $finish;
    end
    
    // Timeout protection
    initial begin
        #1000000;  // 1ms timeout
        $display("ERROR: Simulation timeout!");
        $finish;
    end
    
endmodule
"""

        # Write testbench file
        with open(testbench_path, 'w') as f:
            f.write(testbench_content)
        
        return testbench_path

    def run_modelsim_simulation(self,
                               top_module: str,
                               rtl_files: List[str],
                               testbench_file: str,
                               output_dir: str) -> Dict[str, Any]:
        """Run ModelSim simulation."""
        if not self.modelsim_available:
            return {
                "success": False,
                "error": "ModelSim not available",
                "status": "simulator_unavailable"
            }

        try:
            # Create ModelSim script
            script_content = f"""# ModelSim simulation script for {top_module}

# Create work library
vlib work
vmap work work

# Compile RTL files
"""
            for rtl_file in rtl_files:
                script_content += f"vlog -work work {rtl_file}\n"
            
            script_content += f"""
# Compile testbench
vlog -work work {testbench_file}

# Simulate
vsim -c -do "run -all; quit" work.{top_module}_tb
"""

            script_path = os.path.join(output_dir, f"{top_module}_sim.do")
            with open(script_path, 'w') as f:
                f.write(script_content)

            # Run simulation
            start_time = time.time()
            result = subprocess.run(
                ['vsim', '-c', '-do', f'source {script_path}'],
                cwd=output_dir,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            end_time = time.time()

            # Parse results
            success = result.returncode == 0
            stdout = result.stdout
            stderr = result.stderr

            # Extract test results from output
            test_results = self._parse_simulation_output(stdout)

            return {
                "success": success,
                "simulator": "modelsim",
                "top_module": top_module,
                "simulation_time_seconds": end_time - start_time,
                "stdout": stdout,
                "stderr": stderr,
                "test_results": test_results,
                "script_path": script_path
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "ModelSim simulation timed out",
                "status": "timeout"
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"ModelSim simulation failed: {str(e)}",
                "status": "simulation_error"
            }

    def run_iverilog_simulation(self,
                               top_module: str,
                               rtl_files: List[str],
                               testbench_file: str,
                               output_dir: str) -> Dict[str, Any]:
        """Run Icarus Verilog simulation."""
        if not self.iverilog_available:
            return {
                "success": False,
                "error": "Icarus Verilog not available",
                "status": "simulator_unavailable"
            }

        try:
            # Compile
            vvp_file = os.path.join(output_dir, f"{top_module}_sim")
            compile_cmd = ['iverilog', '-o', vvp_file] + rtl_files + [testbench_file]
            
            compile_result = subprocess.run(
                compile_cmd,
                cwd=output_dir,
                capture_output=True,
                text=True,
                timeout=60
            )

            if compile_result.returncode != 0:
                return {
                    "success": False,
                    "error": f"Compilation failed: {compile_result.stderr}",
                    "status": "compilation_error"
                }

            # Run simulation
            start_time = time.time()
            sim_result = subprocess.run(
                ['vvp', vvp_file],
                cwd=output_dir,
                capture_output=True,
                text=True,
                timeout=300
            )
            end_time = time.time()

            # Parse results
            success = sim_result.returncode == 0
            stdout = sim_result.stdout
            stderr = sim_result.stderr

            # Extract test results from output
            test_results = self._parse_simulation_output(stdout)

            return {
                "success": success,
                "simulator": "iverilog",
                "top_module": top_module,
                "simulation_time_seconds": end_time - start_time,
                "stdout": stdout,
                "stderr": stderr,
                "test_results": test_results,
                "vvp_file": vvp_file
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Icarus Verilog simulation timed out",
                "status": "timeout"
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Icarus Verilog simulation failed: {str(e)}",
                "status": "simulation_error"
            }

    def _parse_simulation_output(self, output: str) -> Dict[str, Any]:
        """Parse simulation output to extract test results."""
        results = {
            "tests_total": 0,
            "tests_passed": 0,
            "tests_failed": 0,
            "max_error": 0.0,
            "rms_error": 0.0,
            "all_passed": False
        }

        # Extract test statistics
        total_match = re.search(r'Total tests:\s*(\d+)', output)
        if total_match:
            results["tests_total"] = int(total_match.group(1))

        passed_match = re.search(r'Passed:\s*(\d+)', output)
        if passed_match:
            results["tests_passed"] = int(passed_match.group(1))

        failed_match = re.search(r'Failed:\s*(\d+)', output)
        if failed_match:
            results["tests_failed"] = int(failed_match.group(1))

        max_error_match = re.search(r'Max error:\s*([\d.]+)', output)
        if max_error_match:
            results["max_error"] = float(max_error_match.group(1))

        rms_error_match = re.search(r'RMS error:\s*([\d.]+)', output)
        if rms_error_match:
            results["rms_error"] = float(rms_error_match.group(1))

        # Check if all tests passed
        if "ALL TESTS PASSED" in output:
            results["all_passed"] = True

        return results

    def run_simulation(self,
                      top_module: str,
                      rtl_files: List[str],
                      test_vectors: Dict[str, Any],
                      simulator: str = "auto",
                      output_dir: Optional[str] = None) -> Dict[str, Any]:
        """
        Run RTL simulation with the specified simulator.

        Args:
            top_module: Top-level module name
            rtl_files: List of RTL file paths
            test_vectors: Test vector data
            simulator: Simulator to use ('auto', 'modelsim', 'questa', 'vcs', 'iverilog')
            output_dir: Output directory (creates temp dir if None)

        Returns:
            Dict with simulation results
        """
        # Create output directory
        if output_dir is None:
            temp_dir = tempfile.mkdtemp(prefix=f"sim_{top_module}_")
            cleanup_temp = True
        else:
            temp_dir = output_dir
            cleanup_temp = False

        try:
            # Generate testbench
            testbench_file = self.generate_testbench(
                top_module, rtl_files, test_vectors, temp_dir
            )

            # Select simulator
            if simulator == "auto":
                available = self.get_available_simulators()
                if 'iverilog' in available:
                    simulator = 'iverilog'  # Prefer open-source
                elif 'modelsim' in available:
                    simulator = 'modelsim'
                elif 'questa' in available:
                    simulator = 'questa'
                elif 'vcs' in available:
                    simulator = 'vcs'
                else:
                    return {
                        "success": False,
                        "error": "No simulators available",
                        "status": "no_simulators"
                    }

            # Run simulation based on selected simulator
            if simulator == "iverilog":
                result = self.run_iverilog_simulation(
                    top_module, rtl_files, testbench_file, temp_dir
                )
            elif simulator in ["modelsim", "questa"]:
                result = self.run_modelsim_simulation(
                    top_module, rtl_files, testbench_file, temp_dir
                )
            else:
                return {
                    "success": False,
                    "error": f"Unsupported simulator: {simulator}",
                    "status": "unsupported_simulator"
                }

            result["testbench_file"] = testbench_file
            result["output_dir"] = temp_dir
            return result

        except Exception as e:
            return {
                "success": False,
                "error": f"Simulation failed: {str(e)}",
                "status": "simulation_error"
            }
        finally:
            if cleanup_temp and os.path.exists(temp_dir):
                shutil.rmtree(temp_dir)


# Global simulator integration instance
simulator_integration = SimulatorIntegration()


@function_tool
def run_rtl_simulation(top_module: str,
                      rtl_files: List[str],
                      input_data: List[float],
                      expected_data: List[float],
                      simulator: str = "auto") -> str:
    """
    Function tool for running real RTL simulation.

    Args:
        top_module: Top-level module name
        rtl_files: List of RTL file paths
        input_data: List of input test vectors
        expected_data: List of expected output vectors
        simulator: Simulator to use ('auto', 'modelsim', 'questa', 'vcs', 'iverilog')

    Returns:
        JSON string with simulation results
    """
    test_vectors = {"input": input_data, "expected": expected_data}
    result = simulator_integration.run_simulation(
        top_module=top_module,
        rtl_files=rtl_files,
        test_vectors=test_vectors,
        simulator=simulator
    )
    return json.dumps(result)


@function_tool
def generate_testbench(top_module: str,
                       rtl_files: List[str],
                       input_data: List[float],
                       expected_data: List[float],
                       output_dir: str) -> str:
    """
    Function tool for generating SystemVerilog testbench.

    Args:
        top_module: Top-level module name
        rtl_files: List of RTL file paths
        input_data: List of input test vectors
        expected_data: List of expected output vectors
        output_dir: Output directory for testbench

    Returns:
        JSON string with testbench generation results
    """
    try:
        test_vectors = {"input": input_data, "expected": expected_data}
        testbench_file = simulator_integration.generate_testbench(
            top_module, rtl_files, test_vectors, output_dir
        )
        
        result = {
            "success": True,
            "testbench_file": testbench_file,
            "output_dir": output_dir,
            "top_module": top_module
        }
        return json.dumps(result)
    except Exception as e:
        result = {
            "success": False,
            "error": f"Testbench generation failed: {str(e)}"
        }
        return json.dumps(result)
