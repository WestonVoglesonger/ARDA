``` path=algorithms/bpf16/algo.py
# algorithms/bpf16/algo.py
# A hardware-friendly, one-sample-per-call FIR (band-pass).
# "step(x)" is the interface the pipeline will recognize:
#   1 input sample in, 1 output sample out (streaming).
#
# You can also call "run_batch(xs)" to process a numpy array.

import numpy as np

# Example 16-tap band-pass coefficients (Fs normalized; illustrative only)
# Centered roughly around ~0.2..0.3 of Nyquist with a Hamming window.
COEFF = np.array([
    -0.0071, -0.0138, -0.0109,  0.0112,
     0.0516,  0.0973,  0.1288,  0.1329,
     0.1044,  0.0482, -0.0159, -0.0704,
    -0.1000, -0.0970, -0.0619, -0.0017
], dtype=np.float64)

class BPF16:
    def __init__(self, coeff=COEFF):
        self.taps = np.array(coeff, dtype=np.float64)
        self.N = len(self.taps)
        self.state = np.zeros(self.N, dtype=np.float64)

    def step(self, x: float) -> float:
        # shift register
        self.state[1:] = self.state[:-1]
        self.state[0] = x
        # dot product
        return float(np.dot(self.taps, self.state))

def run_batch(xs: np.ndarray) -> np.ndarray:
    """Convenience batch API (still uses streaming step internally)."""
    f = BPF16()
    ys = np.empty_like(xs, dtype=np.float64)
    for i, s in enumerate(xs):
        ys[i] = f.step(float(s))
    return ys
```

``` path=algorithms/bpf16/meta.yaml
# algorithms/bpf16/meta.yaml
name: BPF16
description: 16-tap streaming band-pass FIR (1 sample in â†’ 1 sample out)
io:
  # Fixed-point formats you want after Quant stage (can be adjusted by Quant)
  in_width: 12
  in_frac: 11
  out_width: 16
  out_frac: 14
throughput:
  samples_per_cycle: 1
clock_mhz_target: 200
resource_budget:
  lut: 20000
  ff: 40000
  dsp: 40
  bram: 20
verify:
  # How many samples to simulate for the golden check
  num_samples: 1024
  tolerance_abs: 1.0e-2
```

``` path=algorithms/bpf16/vectors.py
# algorithms/bpf16/vectors.py
# Generates a noisy multi-tone input and a golden output using algo.py.
# It saves numpy arrays, so Verify can load them to compute mismatches.

import numpy as np
from algo import run_batch

def make_input(num=1024, seed=1):
    rng = np.random.default_rng(seed)
    n = np.arange(num)
    # Two tones + noise
    x = 0.6*np.sin(2*np.pi*0.08*n) + 0.3*np.sin(2*np.pi*0.28*n) + 0.05*rng.standard_normal(num)
    return x.astype(np.float64)

if __name__ == "__main__":
    xs = make_input()
    ys = run_batch(xs)

    np.save("in.npy", xs)
    np.save("golden.npy", ys)

    # Also provide simple text versions (useful if your Verify expects txt)
    np.savetxt("in.txt", xs, fmt="%.6f")
    np.savetxt("golden.txt", ys, fmt="%.6f")
    print("Wrote in.npy/golden.npy and in.txt/golden.txt")
```
